Name,Suffix,Class,Form,Opcode,XO,Subdec,spr,BO,In,InImpl,Out,OutImpl,Action,Rc,SO,End,AA,LK,Priv,Lock,DE_OP,EXE_OP,MEM_OP,WB_OP,Notes,
,,,,,,,,,,,,,,,,,,,,,,,,,,
add,".,o",Arithmetic,XO,31,266,,,,"RA,RB",,RT,,"ADD_OV(val_RT, val_OV, val_RA, val_RB)",1,1,,,,,,A=RA; B=RB; if (Rc || SO) D=XERCR,R0=alu_add_ab; RC=Rc_SO,R0,RT=R0; if (Rc || SO) XERCR=RC,. means write cr0; o means write XER.OV. This is on top of outimpl.,
addc,".,o",Arithmetic,XO,31,10,,,,"RA,RB",,RT,CA,"ADD_OV_CO(val_RT, val_OV, val_CA, val_RA, val_RB)",1,1,,,,,,A=RA; B=RB; D=XERCR,R0=alu_add_ab; RC=Rc_SO_CA,R0,RT=R0; XERCR=RC,"And these implicitly always write XER.CA, conditionally write XER.SO, CR0",
adde,".,o",Arithmetic,XO,31,138,,,,"RA,RB",CA,RT,CA,"ADD_OV_CO_CI(val_RT, val_OV, val_CA, val_RA, val_RB, val_CA)",1,1,,,,,,A=RA; B=RB; D=XERCR,R0=alu_adc_ab_d; RC=Rc_SO_CA,R0,RT=R0; XERCR=RC,,
addi,,Arithmetic,D,14,,,,,"RA0,SI",,RT,,val_RT = val_RA0 + SI,0,0,,,,,,A=RA0; B=SI,R0=alu_add_ab,R0,RT=R0,,
addis,,Arithmetic,D,15,,,,,"RA0,SI",,RT,,val_RT = val_RA0 + ((REG)SI<<16),0,0,,,,,,A=RA0; B=SI_HI,R0=alu_add_ab,R0,RT=R0,,
addic,,Arithmetic,D,12,,,,,"RA,SI",,RT,CA,"ADD_CO(val_RT, val_CA, val_RA, SI)",0,0,,,,,,A=RA; B=SI; D=XERCR,R0=alu_add_ab; RC=CA,R0,RT=R0; XERCR=RC,,
addic_rc,,Arithmetic,D,13,,,,,"RA,SI",,RT,CA,"ADD_CO(val_RT, val_CA, val_RA, SI)",A,0,,,,,,A=RA; B=SI; D=XERCR,R0=alu_add_ab; RC=RcA_CA,R0,RT=R0; XERCR=RC,,
addme,".,o",Arithmetic,XO,31,234,,,,RA,CA,RT,CA,"ADD_OV_CO_CI(val_RT, val_OV, val_CA, val_RA, -1, val_CA)",1,1,,,,,,A=RA; D=XERCR,R0=alu_adc_a_m1_d; RC=Rc_SO_CA,R0,RT=R0; XERCR=RC,,
addze,".,o",Arithmetic,XO,31,202,,,,RA,CA,RT,CA,"ADD_OV_CO(val_RT, val_OV, val_CA, val_RA, val_CA)",1,1,,,,,,A=RA; D=XERCR,R0=alu_adc_a_0_d; RC=Rc_SO_CA,R0,RT=R0; XERCR=RC,,
and,.,Logical,X,31,28,,,,"RS,RB",,RA,,val_RA = val_RS & val_RB,1,0,,,,,,A=RS; B=RB; if (Rc) D=XERCR,R0=alu_and_ab; RC=Rc,R0,RA=R0; if (Rc) XERCR=RC,,
andc,.,Logical,X,31,60,,,,"RS,RB",,RA,,val_RA = val_RS & ~val_RB,1,0,,,,,,A=RS; B=RB; if (Rc) D=XERCR,R0=alu_andc_ab; RC=Rc,R0,RA=R0; if (Rc) XERCR=RC,,
andi_rc,,Logical,D,28,,,,,"RS,UI",,RA,,val_RA = val_RS & UI,A,0,,,,,,A=RS; B=UI; D=XERCR,R0=alu_and_ab; RC=RcA,R0,RA=R0; XERCR=RC,,
andis_rc,,Logical,D,29,,,,,"RS,UI",,RA,,val_RA = val_RS & ((REG)UI<<16),A,0,,,,,,A=RS; B=UI_HI; D=XERCR,R0=alu_and_ab; RC=RcA,R0,RA=R0; XERCR=RC,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
b,"a,l",Branch,I,18,,,,,"LI,AA",,,LR if LK,,,,1,1,1,,,A=LI,R1=PC4; R2=br_dest_PC_A_AA; br_annul,R1; newpc=R2,if (LK) spr_LR=R1,Adder for branch dest to PC; decode gives offset in A,
,,,,,,,,,,,,,,,,,,,,,,,,,,
bc,"a,l",Branch,B,16,,0,,,"BO,BI,BD","CTR,CR",,"CTR, LR if LK",,,,1,1,1,,,,,,,,
bc,"a,l",Branch,B,16,,1,,0b0000x,"BO,BI,BD","CTR,CR",,"CTR, LR if LK",,,,,1,1,,,A=BD; C=spr_CTR; D=XERCR,"R0=alu_dec_c; R1=PC4; R2=br_dest_PC_A_AA; br_cond_annul(C, NZ)",R0; R1; newpc=R2,spr_CTR=R0; if (LK) spr_LR=R1,"Exe is busy; CTR—, add PC+imm for br_dest, eval cond. Outputs newPC (dedicated port), CTR (regular ALU result), PC (alt ALU result).  Dedicated br adder.",
bc,"a,l",Branch,B,16,,1,,0b0001x,"BO,BI,BD","CTR,CR",,"CTR, LR if LK",,,,,1,1,,,A=BD; C=spr_CTR; D=XERCR,"R0=alu_dec_c; R1=PC4; R2=br_dest_PC_A_AA; br_cond_annul(C, Z)",R0; R1; newpc=R2,spr_CTR=R0; if (LK) spr_LR=R1,,
bc,"a,l",Branch,B,16,,1,,0b001xx,"BO,BI,BD",CR,,LR if LK,,,,,1,1,,,A=BD; D=XERCR,"R1=PC4; R2=br_dest_PC_A_AA; br_cond_annul(C, 1)",R1; newpc=R2,if (LK) spr_LR=R1,,
bc,"a,l",Branch,B,16,,1,,0b0100x,"BO,BI,BD","CTR,CR",,"CTR, LR if LK",,,,,1,1,,,A=BD; C=spr_CTR; D=XERCR,"R0=alu_dec_c; R1=PC4; R2=br_dest_PC_A_AA; br_cond_annul(T, NZ)",R0; R1; newpc=R2,spr_CTR=R0; if (LK) spr_LR=R1,,
bc,"a,l",Branch,B,16,,1,,0b0101x,"BO,BI,BD","CTR,CR",,"CTR, LR if LK",,,,,1,1,,,A=BD; C=spr_CTR; D=XERCR,"R0=alu_dec_c; R1=PC4; R2=br_dest_PC_A_AA; br_cond_annul(T, Z)",R0; R1; newpc=R2,spr_CTR=R0; if (LK) spr_LR=R1,,
bc,"a,l",Branch,B,16,,1,,0b011xx,"BO,BI,BD",CR,,LR if LK,,,,,1,1,,,A=BD; D=XERCR,"R1=PC4; R2=br_dest_PC_A_AA; br_cond_annul(T, 1)",R1; newpc=R2,if (LK) spr_LR=R1,,
bc,"a,l",Branch,B,16,,1,,0b1x00x,"BO,BI,BD",CTR,,"CTR, LR if LK",,,,,1,1,,,A=BD; C=spr_CTR,"R0=alu_dec_c; R1=PC4; R2=br_dest_PC_A_AA; br_cond_annul(1, NZ)",R0; R1; newpc=R2,spr_CTR=R0; if (LK) spr_LR=R1,,
bc,"a,l",Branch,B,16,,1,,0b1x01x,"BO,BI,BD",CTR,,"CTR, LR if LK",,,,,1,1,,,A=BD; C=spr_CTR,"R0=alu_dec_c; R1=PC4; R2=br_dest_PC_A_AA; br_cond_annul(1, Z)",R0; R1; newpc=R2,spr_CTR=R0; if (LK) spr_LR=R1,,
bc,"a,l",Branch,B,16,,1,,0b1x1xx,"BO,BI,BD",,,LR if LK,,,,,1,1,,,A=BD,R1=PC4; R2=br_dest_PC_A_AA; br_annul,R1; newpc=R2,if (LK) spr_LR=R1,NOTE: BO was 0b1x10x,
,,,,,,,,,,,,,,,,,,,,,,,,,,
bclr,l,Branch,XL,19,16,0,,,"BO,BI,BH","CTR,CR,LR",,"CTR, LR if LK",,,,1,0,1,,,,,,,,
bclr,l,Branch,XL,19,16,1,,0b0000x,"BO,BI,BH","CTR,CR,LR",,"CTR, LR if LK",,,,,0,1,,,A=spr_LR; C=spr_CTR; D=XERCR,"R0=alu_dec_c; R1=PC4; R2=br_dest_A; br_cond_annul(C, NZ)",R0; R1; newpc=R2,spr_CTR=R0; if (LK) spr_LR=R1,"br_dest_A is effectively just a move, but zeroes bottom bits.",
bclr,l,Branch,XL,19,16,1,,0b0001x,"BO,BI,BH","CTR,CR,LR",,"CTR, LR if LK",,,,,0,1,,,A=spr_LR; C=spr_CTR; D=XERCR,"R0=alu_dec_c; R1=PC4; R2=br_dest_A; br_cond_annul(C, Z)",R0; R1; newpc=R2,spr_CTR=R0; if (LK) spr_LR=R1,,
bclr,l,Branch,XL,19,16,1,,0b001xx,"BO,BI,BH","CR,LR",,LR if LK,,,,,0,1,,,A=spr_LR; D=XERCR,"R1=PC4; R2=br_dest_A; br_cond_annul(C, 1)",R1; newpc=R2,if (LK) spr_LR=R1,,
bclr,l,Branch,XL,19,16,1,,0b0100x,"BO,BI,BH","CTR,CR,LR",,"CTR, LR if LK",,,,,0,1,,,A=spr_LR; C=spr_CTR; D=XERCR,"R0=alu_dec_c; R1=PC4; R2=br_dest_A; br_cond_annul(T, NZ)",R0; R1; newpc=R2,spr_CTR=R0; if (LK) spr_LR=R1,,
bclr,l,Branch,XL,19,16,1,,0b0101x,"BO,BI,BH","CTR,CR,LR",,"CTR, LR if LK",,,,,0,1,,,A=spr_LR; C=spr_CTR; D=XERCR,"R0=alu_dec_c; R1=PC4; R2=br_dest_A; br_cond_annul(T, Z)",R0; R1; newpc=R2,spr_CTR=R0; if (LK) spr_LR=R1,,
bclr,l,Branch,XL,19,16,1,,0b011xx,"BO,BI,BH","CR,LR",,LR if LK,,,,,0,1,,,A=spr_LR; D=XERCR,"R1=PC4; R2=br_dest_A; br_cond_annul(T, 1)",R1; newpc=R2,if (LK) spr_LR=R1,,
bclr,l,Branch,XL,19,16,1,,0b1x00x,"BO,BI,BH","CTR,LR",,"CTR, LR if LK",,,,,0,1,,,A=spr_LR; C=spr_CTR; D=XERCR,"R0=alu_dec_c; R1=PC4; R2=br_dest_A; br_cond_annul(1, NZ)",R0; R1; newpc=R2,spr_CTR=R0; if (LK) spr_LR=R1,,
bclr,l,Branch,XL,19,16,1,,0b1x01x,"BO,BI,BH","CTR,LR",,"CTR, LR if LK",,,,,0,1,,,A=spr_LR; C=spr_CTR; D=XERCR,"R0=alu_dec_c; R1=PC4; R2=br_dest_A; br_cond_annul(1, Z)",R0; R1; newpc=R2,spr_CTR=R0; if (LK) spr_LR=R1,,
bclr,l,Branch,XL,19,16,1,,0b1x1xx,"BO,BI,BH",LR,,LR if LK,,,,,0,1,,,A=spr_LR,R1=PC4; R2=br_dest_A; br_annul,R1; newpc=R2,if (LK) spr_LR=R1,NOTE: BO was 0b1x10x,
,,,,,,,,,,,,,,,,,,,,,,,,,,
bcctr,l,Branch,XL,19,528,0,,,"BO,BI,BH","CTR,CR",,LR if LK,,,,1,0,1,,,,,,,,
bcctr,l,Branch,XL,19,528,1,,0b001xx,"BO,BI,BH","CTR,CR",,LR if LK,,,,,0,1,,,C=spr_CTR; D=XERCR,"R1=PC4; R2=br_dest_C; br_cond_annul(C, 1)",R1; newpc=R2,if (LK) spr_LR=R1,See br_dest_A note above.,
bcctr,l,Branch,XL,19,528,1,,0b011xx,"BO,BI,BH","CTR,CR",,LR if LK,,,,,0,1,,,C=spr_CTR; D=XERCR,"R1=PC4; R2=br_dest_C; br_cond_annul(T, 1)",R1; newpc=R2,if (LK) spr_LR=R1,,
bcctr,l,Branch,XL,19,528,1,,0b1x1xx,"BO,BI,BH",CTR,,LR if LK,,,,,0,1,,,C=spr_CTR,R1=PC4; R2=br_dest_C; br_annul,R1; newpc=R2,if (LK) spr_LR=R1,NOTE: BO was 0b1x10x,
,,,,,,,,,,,,,,,,,,,,,,,,,,
cmp,,Compare,X,31,0,,,,"BF,RA,RB",CR,,CR,"WRITE_CR_FIELD(val_CR, BF, CMP(val_RA, val_RB))",,,,,,,,A=RB; B=RA; C=BF; D=XERCR,R0=alu_sub_ba; RC=cmp_ab_c,,XERCR=RC,Writes CRn,
cmpi,,Compare,D,11,,,,,"BF,RA,SI",CR,,CR,"WRITE_CR_FIELD(val_CR, BF, CMP(val_RA, SI))",,,,,,,,A=SI; B=RA; C=BF; D=XERCR,R0=alu_sub_ba; RC=cmp_ab_c,,XERCR=RC,,
cmpl,,Compare,X,31,32,,,,"BF,RA,RB",CR,,CR,"WRITE_CR_FIELD(val_CR, BF, CMPu(val_RA, val_RB))",,,,,,,,A=RB; B=RA; C=BF; D=XERCR,R0=alu_sub_ba; RC=cmpu_ab_c,,XERCR=RC,,
cmpli,,Compare,D,10,,,,,"BF,RA,UI",CR,,CR,"WRITE_CR_FIELD(val_CR, BF, CMPu(val_RA, UI))",,,,,,,,A=UI; B=RA; C=BF; D=XERCR,R0=alu_sub_ba; RC=cmpu_ab_c,,XERCR=RC,,
cntlzw,.,Logical,X,31,26,,,,RS,,RA,,,1,,,,,,,A=RS; if (Rc) D=XERCR,R0=misc_cntlzw_a; RC=Rc,R0,RA=R0; if (Rc) XERCR=RC,,
crand,,CondReg,XL,19,257,,,,"BT,BA,BB",CR,,CR,"WBIT(val_CR, BT, RBIT(val_CR, BA) & RBIT(val_CR, BB))",,,,,,,,A=BA; B=BB; C=BT; D=XERCR,RC=cr_and_abc,,XERCR=RC,,
crandc,,CondReg,XL,19,129,,,,"BT,BA,BB",CR,,CR,"WBIT(val_CR, BT, RBIT(val_CR, BA) & ~RBIT(val_CR, BB))",,,,,,,,A=BA; B=BB; C=BT; D=XERCR,RC=cr_andc_abc,,XERCR=RC,,
creqv,,CondReg,XL,19,289,,,,"BT,BA,BB",CR,,CR,"WBIT(val_CR, BT, ~(RBIT(val_CR, BA) ^ RBIT(val_CR, BB)))",,,,,,,,A=BA; B=BB; C=BT; D=XERCR,RC=cr_eqv_abc,,XERCR=RC,,
crnand,,CondReg,XL,19,225,,,,"BT,BA,BB",CR,,CR,"WBIT(val_CR, BT, ~(RBIT(val_CR, BA) & RBIT(val_CR, BB)))",,,,,,,,A=BA; B=BB; C=BT; D=XERCR,RC=cr_nand_abc,,XERCR=RC,,
crnor,,CondReg,XL,19,33,,,,"BT,BA,BB",CR,,CR,"WBIT(val_CR, BT, ~(RBIT(val_CR, BA) | RBIT(val_CR, BB)))",,,,,,,,A=BA; B=BB; C=BT; D=XERCR,RC=cr_nor_abc,,XERCR=RC,,
cror,,CondReg,XL,19,449,,,,"BT,BA,BB",CR,,CR,"WBIT(val_CR, BT, RBIT(val_CR, BA) | RBIT(val_CR, BB))",,,,,,,,A=BA; B=BB; C=BT; D=XERCR,RC=cr_or_abc,,XERCR=RC,,
crorc,,CondReg,XL,19,417,,,,"BT,BA,BB",CR,,CR,"WBIT(val_CR, BT, RBIT(val_CR, BA) | ~RBIT(val_CR, BB))",,,,,,,,A=BA; B=BB; C=BT; D=XERCR,RC=cr_orc_abc,,XERCR=RC,,
crxor,,CondReg,XL,19,193,,,,"BT,BA,BB",CR,,CR,"WBIT(val_CR, BT, RBIT(val_CR, BA) ^ RBIT(val_CR, BB))",,,,,,,,A=BA; B=BB; C=BT; D=XERCR,RC=cr_xor_abc,,XERCR=RC,,
divw,".,o",Arithmetic,XO,31,491,,,,"RA,RB",,RT,,,1,1,,,,,,A=RA; B=RB; if (Rc || SO) D=XERCR,R0=div_ab; RC=Rc_SO,R0,RT=R0; if (Rc || SO) XERCR=RC,Check SO,
divwu,".,o",Arithmetic,XO,31,459,,,,"RA,RB",,RT,,,1,1,,,,,,A=RA; B=RB; if (Rc || SO) D=XERCR,R0=div_u_ab; RC=Rc_SO,R0,RT=R0; if (Rc || SO) XERCR=RC,Check SO,
eieio,,Special,X,31,854,,,,,,,,,,,,,,,,,,,,Barrier — NOP for now,
eqv,.,Logical,X,31,284,,,,"RS,RB",,RA,,val_RA = ~(val_RS ^ val_RB),1,,,,,,,A=RS; B=RB; if (Rc) D=XERCR,R0=alu_nxor_ab; RC=Rc,R0,RA=R0; if (Rc) XERCR=RC,TEST THIS,
extsb,.,Logical,X,31,954,,,,RS,,RA,,val_RA = SXT8(val_RS),1,,,,,,,A=RS; if (Rc) D=XERCR,R0=sxt_8_a; RC=Rc,R0,RA=R0; if (Rc) XERCR=RC,"WB does this on mem_result, could re-use that? (But want Rc/CR0 update which is much easier in EXE, so duplicate SXT.)",
extsh,.,Logical,X,31,922,,,,RS,,RA,,val_RA = SXT16(val_RS),1,,,,,,,A=RS; if (Rc) D=XERCR,R0=sxt_16_a; RC=Rc,R0,RA=R0; if (Rc) XERCR=RC,,
isync,,Special,XL,19,150,,,,,,,,,,,,,,,,,R2=PC4; br_annul,newpc=R2,,Simple barrier; drain PL. Assert newpc with pc+4,
lbz,,Memory,D,34,,,,,"RA0,D",,RT,,val_RT=LOAD8(val_RA0 + D) ; MFCHECK(1),,,,,,,,A=RA0; B=D,R0=alu_add_ab,L8,RT=mem_res,,
lbzu,,Memory,D,35,,,,,"RA,D",,"RT,RA",,ADR x = val_RA + D ; val_RT = LOAD8(x) ; val_RA = x ; MFCHECK(1),,,,,,,,A=RA; B=D,R0=alu_add_ab,R0; L8,RT=mem_res; RA=R0,FIXME: UNDEF if RA=0,
lbzx,,Memory,X,31,87,,,,"RA0,RB",,RT,,val_RT = LOAD8(val_RA0 + val_RB) ; MFCHECK(1),,,,,,,,A=RA0; B=RB,R0=alu_add_ab,L8,RT=mem_res,,
lbzux,,Memory,X,31,119,,,,"RA,RB",,"RT,RA",,ADR x = val_RA + val_RB ; val_RT = LOAD8(x) ; val_RA = x ; MFCHECK(1),,,,,,,,A=RA; B=RB,R0=alu_add_ab,R0; L8,RT=mem_res; RA=R0,FIXME: UNDEF if RA=0,
lha,,Memory,D,42,,,,,"RA0,D",,RT,,val_RT = SXT16(LOAD16(val_RA0 + D)) ; MFCHECK(1),,,,,,,,A=RA0; B=D,R0=alu_add_ab,L16,RT=sxt16_mem_res,,
lhau,,Memory,D,43,,,,,"RA,D",,"RT,RA",,ADR x = val_RA + D ; val_RT = SXT16(LOAD16(x)) ; val_RA = x ; MFCHECK(1),,,,,,,,A=RA; B=D,R0=alu_add_ab,R0; L16,RT=sxt16_mem_res; RA=R0,FIXME: UNDEF if RA=0,
lhax,,Memory,X,31,343,,,,"RA0,RB",,RT,,val_RT = SXT16(LOAD16(val_RA0 + val_RB)) ; MFCHECK(1),,,,,,,,A=RA0; B=RB,R0=alu_add_ab,L16,RT=sxt16_mem_res,,
lhaux,,Memory,X,31,375,,,,"RA,RB",,"RT,RA",,ADR x = val_RA + val_RB ; val_RT = SXT16(LOAD16(x)) ; val_RA = x ; MFCHECK(1),,,,,,,,A=RA; B=RB,R0=alu_add_ab,R0; L16,RT=sxt16_mem_res; RA=R0,FIXME: UNDEF if RA=0,
lhbrx,,Memory,X,31,790,,,,"RA0,RB",,RT,,val_RT = BSWAP16(LOAD16(val_RA0 + val_RB)) ; MFCHECK(1),,,,,,,,A=RA0; B=RB,R0=alu_add_ab,L16,RT=bswap16_mem_res,,
lhz,,Memory,D,40,,,,,"RA0,D",,RT,,val_RT = LOAD16(val_RA0 + D) ; MFCHECK(1),,,,,,,,A=RA0; B=D,R0=alu_add_ab,L16,RT=mem_res,,
lhzu,,Memory,D,41,,,,,"RA,D",,"RT,RA",,ADR x = val_RA + D ; val_RT = LOAD16(x) ; val_RA = x ; MFCHECK(1),,,,,,,,A=RA; B=D,R0=alu_add_ab,R0; L16,RT=mem_res; RA=R0,FIXME: UNDEF if RA=0,
lhzx,,Memory,X,31,279,,,,"RA0,RB",,RT,,val_RT = LOAD16(val_RA0 + val_RB) ; MFCHECK(1),,,,,,,,A=RA0; B=RB,R0=alu_add_ab,L16,RT=mem_res,,
lhzux,,Memory,X,31,311,,,,"RA,RB",,"RT,RA",,ADR x = val_RA + val_RB ; val_RT = LOAD16(x) ; val_RA = x ; MFCHECK(1),,,,,,,,A=RA; B=RB,R0=alu_add_ab,R0; L16,RT=mem_res; RA=R0,FIXME: UNDEF if RA=0,
lmw,,Memory,D,46,,,,,"RT,D,RA0",,,,,,,,,,,,A=RA0; B=D; state_lmw,R0=alu_add_ab,L32,RT=mem_res,DE does load_RX.  DE multi-cycle:  split into lwzu,
lmw-state_lmw,,Synthetic,,,,,,,,,,,,,,,,,,,,R0=alu_add_R0_4,L32,RX=mem_res,DE does inc_X,
lswi,,Memory,X,31,597,,,,"RT,RA0,NB",,,,,,,,,,H,,FC_ILL_HYP,,,,String,
lswx,,Memory,X,31,533,,,,"RT,RA0,RB",,,,,,,,,,H,,FC_ILL_HYP,,,,String,
lwarx,,Memory,X,31,20,,,,"RA0,RB,EH",,RT,,,,,,,,,,A=RA0; B=RB,R0=alu_add_ab,L32; RZV,RT=mem_res,synch.  Ignore EH.,
lwbrx,,Memory,X,31,534,,,,"RA0,RB",,RT,,val_RT = BSWAP32(LOAD32(val_RA0 + val_RB)) ; MFCHECK(1),,,,,,,,A=RA0; B=RB,R0=alu_add_ab,L32,RT=bswap32_mem_res,,
lwz,,Memory,D,32,,,,,"RA0,D",,RT,,val_RT = LOAD32(val_RA0 + D) ; MFCHECK(1),,,,,,,,A=RA0; B=D,R0=alu_add_ab,L32,RT=mem_res,,
lwzu,,Memory,D,33,,,,,"RA,D",,"RT,RA",,ADR x = val_RA + D ; val_RT = LOAD32(x) ; val_RA = x ; MFCHECK(1),,,,,,,,A=RA; B=D,R0=alu_add_ab,R0; L32,RT=mem_res; RA=R0,,
lwzx,,Memory,X,31,23,,,,"RA0,RB",,RT,,val_RT = LOAD32(val_RA0 + val_RB) ; MFCHECK(1),,,,,,,,A=RA0; B=RB,R0=alu_add_ab,L32,RT=mem_res,,
lwzux,,Memory,X,31,55,,,,"RA,RB",,"RT,RA",,ADR x = val_RA + val_RB ; val_RT = LOAD32(x) ; val_RA = x ; MFCHECK(1),,,,,,,,A=RA; B=RB,R0=alu_add_ab,R0; L32,RT=mem_res; RA=R0,,
mcrf,,CondReg,XL,19,0,,,,"BF,BFA",CR,,CR,,,,,,,,,B=BFA; C=BF; D=XERCR,RC=cr_copy_cr4_bcd,,XERCR=RC,"Copies entire 4-bit CR field, not just one bit.",
mcrxr,,CondReg,X,31,512,,,,BF,,,,,,,,,,,,FC_ILL_HYP,,,,"Deprecated, leads to SIGILL in v2.01+. BUT, supported in 750. :(",
mfcr,,CondReg,XFX,31,19,,,,,CR,RT,,,,,,,,,,D=XERCR,R1=D_TO_CR,R1,RT=R1,alu_res = CR,
mfmsr,,Special,X,31,83,,,,,MSR,RT,,val_RT = READ_MSR(),,,,,,S,,,R1=MSR,R1,RT=R1,MSR source,
,,,,,,,,,,,,,,,,,,,,,,,,,,
mfspr,,Special,XFX,31,339,0,,,spr,,RT,,,,,,,,,,,,,,RT=SPR[spr]; various registers incl TB/DEC.  See other sheet.,
mfspr,,Special,XFX,31,339,1,1,,spr,,RT,,,,,,,,,,D=XERCR,R1=D_TO_XER,R1,RT=R1,"Can SPRs go into a different port, e.g. C or D?",
mfspr,,Special,XFX,31,339,1,8,,spr,,RT,,,,,,,,,,C=spr_LR,R0=C,R0,RT=R0,,
mfspr,,Special,XFX,31,339,1,9,,spr,,RT,,,,,,,,,,C=spr_CTR,R0=C,R0,RT=R0,,
mfspr,,Special,XFX,31,339,1,18,,spr,,RT,,,,,,,,S,1,C=spr_DSISR,R0=C,R0,RT=R0,Some regs are rarely-accessed: no forwarding/locking!,
mfspr,,Special,XFX,31,339,1,19,,spr,,RT,,,,,,,,S,1,C=spr_DAR,R0=C,R0,RT=R0,Implement a 'generic lock-all’?  RAW needs to work.,
mfspr,,Special,XFX,31,339,1,22,,spr,,RT,,,,,,,,S,1,C=spr_DEC,R0=C,R0,RT=R0,,
mfspr,,Special,XFX,31,339,1,25,,spr,,RT,,,,,,,,S,1,C=spr_SDR1,R0=C,R0,RT=R0,,
mfspr,,Special,XFX,31,339,1,26,,spr,,RT,,,,,,,,S,1,C=spr_SRR0,R0=C,R0,RT=R0,,
mfspr,,Special,XFX,31,339,1,27,,spr,,RT,,,,,,,,S,1,C=spr_SRR1,R0=C,R0,RT=R0,,
mfspr,,Special,XFX,31,339,1,268,,spr,,RT,,,,,,,,,1,C=spr_TBL,R0=C,R0,RT=R0,,
mfspr,,Special,XFX,31,339,1,269,,spr,,RT,,,,,,,,,1,C=spr_TBU,R0=C,R0,RT=R0,,
mfspr,,Special,XFX,31,339,1,272,,spr,,RT,,,,,,,,S,,C=spr_SPRG0,R0=C,R0,RT=R0,Add HV-mode SPRGs,
mfspr,,Special,XFX,31,339,1,273,,spr,,RT,,,,,,,,S,,C=spr_SPRG1,R0=C,R0,RT=R0,,
mfspr,,Special,XFX,31,339,1,274,,spr,,RT,,,,,,,,S,,C=spr_SPRG2,R0=C,R0,RT=R0,,
mfspr,,Special,XFX,31,339,1,275,,spr,,RT,,,,,,,,S,,C=spr_SPRG3,R0=C,R0,RT=R0,,
mfspr,,Special,XFX,31,339,1,287,,spr,,RT,,,,,,,,S,1,C=spr_PVR,R0=C,R0,RT=R0,,
mfspr,,Special,XFX,31,339,1,0b1000x10xxx,,spr,,RT,,,,,,,,S,1,C=spr_IBAT(bat_idx),R0=C,R0,RT=R0,,
mfspr,,Special,XFX,31,339,1,0b1000x11xxx,,spr,,RT,,,,,,,,S,1,C=spr_DBAT(bat_idx),R0=C,R0,RT=R0,,
mfspr,,Special,XFX,31,339,1,1013,,spr,,RT,,,,,,,,S,1,C=spr_DABR,R0=C,R0,RT=R0,,
mfspr,,Special,XFX,31,339,1,1023,,spr,,RT,,,,,,,,S,1,C=spr_DEBUG,R0=C,R0,RT=R0,Debug access— not a real register.  getch?,
mfspr,,Special,XFX,31,339,1,1008,,spr,,RT,,,,,,,,S,1,C=spr_HID0,R0=C,R0,RT=R0,"Currently nothing in here, RAZ.",
,,,,,,,,,,,,,,,,,,,,,,,,,,
mftb,,Special,XFX,31,371,0,,,spr,,RT,,,,,,,,,,,,,,User access to TBU/TBL,
mftb,,Special,XFX,31,371,1,268,,spr,,RT,,,,,,,,,1,C=spr_TBL,R0=C,R0,RT=R0,,
mftb,,Special,XFX,31,371,1,269,,spr,,RT,,,,,,,,,1,C=spr_TBU,R0=C,R0,RT=R0,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
mtcrf,,CondReg,XFX,31,144,,,,"FXM,RS",,,CR,,,,,,,,,A=FXM; B=RS; D=XERCR,RC=cr_insert_abd,,XERCR=RC,,
mtmsr,,Special,X,31,146,,,,RS,,,MSR,WRITE_MSR(val_RS); (void)val_MSR,,,2,,,S,,A=RS,R0=A; R2=PC4; br_annul,newmsr=R0; newpc=R2,,Looks like RFI but with implicit PC.  Self-synchronising.  (Execution synchronizing?),
,,,,,,,,,,,,,,,,,,,,,,,,,,
mtspr,,Special,XFX,31,467,0,,,"spr,RS",,,,,,,,,,,,,,,,FIXME:  Must flush p’line for some SPRs.  SPRS[spr] = RS,
mtspr,,Special,XFX,31,467,1,1,,"spr,RS",,,,,,,,,,,,B=RS; D=XERCR,RC=cr_insert_b,,XERCR=RC,,
mtspr,,Special,XFX,31,467,1,8,,"spr,RS",,,,,,,,,,,,B=RS,R1=B,R1,spr_LR=R1,Don’t think I need a full flush; arch requires isync...,
mtspr,,Special,XFX,31,467,1,9,,"spr,RS",,,,,,,,,,,,A=RS,R0=A,R0,spr_CTR=R0,Change of IBAT etc. or IR/DR = unpred?,
mtspr,,Special,XFX,31,467,1,18,,"spr,RS",,,,,,,,,,S,1,B=RS,R1=B,R1,spr_DSISR=R1,,
mtspr,,Special,XFX,31,467,1,19,,"spr,RS",,,,,,,,,,S,1,A=RS,R0=A,R0,spr_DAR=R0,,
mtspr,,Special,XFX,31,467,1,22,,"spr,RS",,,,,,,,,,S,1,A=RS,R0=A,R0,spr_DEC=R0,,
mtspr,,Special,XFX,31,467,1,25,,"spr,RS",,,,,,,,,,S,1,A=RS,R0=A,R0,spr_SDR1=R0,,
mtspr,,Special,XFX,31,467,1,26,,"spr,RS",,,,,,,,,,S,1,A=RS,R0=A,R0,spr_SRR0=R0,,
mtspr,,Special,XFX,31,467,1,27,,"spr,RS",,,,,,,,,,S,1,B=RS,R1=B,R1,spr_SRR1=R1,,
mtspr,,Special,XFX,31,467,1,272,,"spr,RS",,,,,,,,,,S,,A=RS,R0=A,R0,spr_SPRG0=R0,,
mtspr,,Special,XFX,31,467,1,273,,"spr,RS",,,,,,,,,,S,,A=RS,R0=A,R0,spr_SPRG1=R0,,
mtspr,,Special,XFX,31,467,1,274,,"spr,RS",,,,,,,,,,S,,A=RS,R0=A,R0,spr_SPRG2=R0,,
mtspr,,Special,XFX,31,467,1,275,,"spr,RS",,,,,,,,,,S,,A=RS,R0=A,R0,spr_SPRG3=R0,,
mtspr,,Special,XFX,31,467,1,284,,"spr,RS",,,,,,,,,,S,1,A=RS,R0=A,R0,spr_TBL=R0,Doesn't alter TBU,
mtspr,,Special,XFX,31,467,1,285,,"spr,RS",,,,,,,,,,S,1,A=RS,R0=A,R0,spr_TBU=R0,Doesn't alter TBL,
mtspr,,Special,XFX,31,467,1,0b1000x10xxx,,"spr,RS",,,,,,,,,,S,1,A=RS,R0=A,R0,spr_IBAT(bat_idx)=R0,,
mtspr,,Special,XFX,31,467,1,0b1000x11xxx,,"spr,RS",,,,,,,,,,S,1,A=RS,R0=A,R0,spr_DBAT(bat_idx)=R0,,
mtspr,,Special,XFX,31,467,1,1013,,"spr,RS",,,,,,,,,,S,1,A=RS,R0=A,R0,spr_DABR=R0,,
mtspr,,Special,XFX,31,467,1,1021,,"spr,RS",,,,,,,,,,H,1,A=RS,R0=A,IC_INV_SET,,ICache set invalidate by index given in R0[N:5],IMPDEF
mtspr,,Special,XFX,31,467,1,1022,,"spr,RS",,,,,,,,,,H,1,A=RS,R0=A,DC_INV_SET,,DCache set invalidate by index given in R0[N:5],IMPDEF
mtspr,,Special,XFX,31,467,1,1023,,"spr,RS",,,,,,,,,,H,1,A=RS,R0=A,R0,spr_DEBUG=R0,"Debug SPR has side-effects, e.g. exit, putchar!  0xXXYY; XX=0 exit(YY), XX=1 putch(YY)",IMPDEF
mtspr,,Special,XFX,31,467,1,1008,,,,,,,,,,,,H,,,,,,HID0 is RAZ/WI (for now),IMPDEF
,,,,,,,,,,,,,,,,,,,,,,,,,,
mulhw,.,Arithmetic,X,31,75,,,,"RA,RB",,RT,,val_RT = ((s64)(s32)val_RA * (s64)(s32)val_RB)>>32,1,,,,,,,A=RA; B=RB; if (Rc) D=XERCR,R0=mul_hw_ab; RC=Rc,R0,RT=R0; if (Rc) XERCR=RC,"High 32. NOTE: XO w/o OE! Hack, said it’s X.",
mulhwu,.,Arithmetic,X,31,11,,,,"RA,RB",,RT,,val_RT = ((u64)val_RA * (u64)val_RB)>>32,1,,,,,,,A=RA; B=RB; if (Rc) D=XERCR,R0=mul_hwu_ab; RC=Rc,R0,RT=R0; if (Rc) XERCR=RC,"High 32 unsigned. NOTE: XO, no OE, said X.",
mulli,,Arithmetic,D,7,,,,,"RA,SI",,RT,,val_RT = val_RA * SI,,,,,,,,A=RA; B=SI,R0=mul_ab,R0,RT=R0,?? 64-bit instruction set?,
mullw,".,o",Arithmetic,XO,31,235,,,,"RA,RB",,RT,,u64 x = (s64)(s32)val_RA * (s64)(s32)val_RB; val_RT = x; val_OV = ((x >> 32) != 0 && (x >> 31) != 0x1ffffffff) || (((SIGN(val_RA) ^ SIGN(val_RB)) != SIGN(x)) && x),1,1,,,,,,A=RA; B=RB; if (Rc || SO) D=XERCR,R0=mul_ab; RC=Rc_SO,R0,RT=R0; if (Rc || SO) XERCR=RC,Lower 32,
nand,.,Logical,X,31,476,,,,"RS,RB",,RA,,val_RA = ~(val_RS & val_RB),1,,,,,,,A=RS; B=RB; if (Rc) D=XERCR,R0=alu_nand_ab; RC=Rc,R0,RA=R0; if (Rc) XERCR=RC,,
neg,".,o",Logical,XO,31,104,,,,RA,,RT,,"ADD_OV(val_RT, val_OV, ~val_RA, 1)",1,1,,,,,,A=RA; if (Rc || SO) D=XERCR,R0=alu_neg_a; RC=Rc_SO,R0,RT=R0; if (Rc || SO) XERCR=RC,,
nor,.,Logical,X,31,124,,,,"RS,RB",,RA,,val_RA = ~(val_RS | val_RB),1,,,,,,,A=RS; B=RB; if (Rc) D=XERCR,R0=alu_nor_ab; RC=Rc,R0,RA=R0; if (Rc) XERCR=RC,,
or,.,Logical,X,31,444,,,,"RS,RB",,RA,,val_RA = val_RS | val_RB,1,,,,,,,A=RS; B=RB; if (Rc) D=XERCR,R0=alu_or_ab; RC=Rc,R0,RA=R0; if (Rc) XERCR=RC,,
orc,.,Logical,X,31,412,,,,"RS,RB",,RA,,val_RA = val_RS | ~val_RB,1,,,,,,,A=RS; B=RB; if (Rc) D=XERCR,R0=alu_orc_ab; RC=Rc,R0,RA=R0; if (Rc) XERCR=RC,,
ori,,Logical,D,24,,,,,"RS,UI",,RA,,val_RA = val_RS | UI,,,,,,,,A=RS; B=UI,R0=alu_or_ab,R0,RA=R0,,
oris,,Logical,D,25,,,,,"RS,UI",,RA,,val_RA = val_RS | ((REG)UI<<16),,,,,,,,A=RS; B=UI_HI,R0=alu_or_ab,R0,RA=R0,,
rfi,,Special,XL,19,50,,,,,"SRR0, SRR1",,,,,,2,,,S,,A=spr_SRR1; C=spr_SRR0,R0=A; R2=C; br_annul,newmsr=R0; newpc=R2,,Return from exception.  Needs 2 results from ALU/MEM to pass PC (SRR0) and MSR (SRR1).  Looks like a branch except MSR written.,
rlwimi,.,Logical,M,20,,,,,"RA,RS,SH,MB,ME",,RA,,,1,,,,,,,A=RS; B=RA; C=SH_MB_ME; if (Rc) D=XERCR,R0=sh_rlwimi_abc; RC=Rc,R0,RA=R0; if (Rc) XERCR=RC,,
rlwinm,.,Logical,M,21,,,,,"RS,SH,MB,ME",,RA,,,1,,,,,,,A=RS; B=SH; C=MB_ME; if (Rc) D=XERCR,R0=sh_rlwnm_abc; RC=Rc,R0,RA=R0; if (Rc) XERCR=RC,,
rlwnm,.,Logical,M,23,,,,,"RB,RS,MB,ME",,RA,,,1,,,,,,,A=RS; B=RB; C=MB_ME; if (Rc) D=XERCR,R0=sh_rlwnm_abc; RC=Rc,R0,RA=R0; if (Rc) XERCR=RC,,
sc,,Trap,SC,17,1,,,,LEV,,,,,,,2,,,,,FC_SC,,,,TRAP,
slw,.,Logical,X,31,24,,,,"RS,RB",,RA,,int sh = (val_RB & 0x3f); val_RA = sh & 0x20 ? 0 : (val_RS << (val_RB & 0x1f)),1,,,,,,,A=RS; B=RB; if (Rc) D=XERCR,R0=sh_slw_ab; RC=Rc,R0,RA=R0; if (Rc) XERCR=RC,,
sraw,.,Logical,X,31,792,,,,"RS,RB",,RA,CA,,1,,,,,,,A=RS; B=RB; D=XERCR,R0=sh_sraw_ab; RC=Rc_CA,R0,RA=R0; XERCR=RC,Shift through carry,
srawi,.,Logical,X,31,824,,,,"RS,SH",,RA,CA,,1,,,,,,,A=RS; B=SH; D=XERCR,R0=sh_sraw_ab; RC=Rc_CA,R0,RA=R0; XERCR=RC,Shift through carry,
srw,.,Logical,X,31,536,,,,"RS,RB",,RA,,val_RA = (val_RB & 0x20) ? 0 :(uint32_t)val_RS >> (val_RB & 0x1f),1,,,,,,,A=RS; B=RB; if (Rc) D=XERCR,R0=sh_srw_ab; RC=Rc,R0,RA=R0; if (Rc) XERCR=RC,,
stb,,Memory,D,38,,,,,"RS,RA0,D",,,,"STORE8(val_RA0 + D, val_RS) ; MFCHECK(0)",,,,,,,,A=RA0; B=D; C=RS,R0=alu_add_ab; R2=C,S8,,MEM stores alu_res_b to [alu_res],
stbu,,Memory,D,39,,,,,"RS,RA,D",,RA,,"ADR x = val_RA+D ; STORE8(x, val_RS); val_RA = x ; MFCHECK(0)",,,,,,,,A=RA; B=D; C=RS,R0=alu_add_ab; R2=C,S8; R0,RA=R0,FIXME: UNDEF if RA=0,
stbx,,Memory,X,31,215,,,,"RS,RA0,RB",,,,"STORE8(val_RA0 + val_RB, val_RS) ; MFCHECK(0)",,,,,,,,A=RA0; B=RB; C=RS,R0=alu_add_ab; R2=C,S8,,,
stbux,,Memory,X,31,247,,,,"RS,RA,RB",,RA,,"ADR x = val_RA + val_RB ; STORE8(x, val_RS); val_RA = x ; MFCHECK(0)",,,,,,,,A=RA; B=RB; C=RS,R0=alu_add_ab; R2=C,S8; R0,RA=R0,FIXME: UNDEF if RA=0,
sth,,Memory,D,44,,,,,"RS,RA0,D",,,,"STORE16(val_RA0 + D, val_RS) ; MFCHECK(0)",,,,,,,,A=RA0; B=D; C=RS,R0=alu_add_ab; R2=C,S16,,,
sthbrx,,Memory,X,31,918,,,,"RS,RA0,RB",,,,"STORE16(val_RA0 + val_RB, BSWAP16(val_RS)) ; MFCHECK(0)",,,,,,,,A=RA0; B=RB; C=RS,R0=alu_add_ab; R2=C,S16_BS,,,
sthu,,Memory,D,45,,,,,"RS,RA,D",,RA,,"ADR x = val_RA + D ; STORE16(x, val_RS); val_RA = x ; MFCHECK(0)",,,,,,,,A=RA; B=D; C=RS,R0=alu_add_ab; R2=C,S16; R0,RA=R0,FIXME: UNDEF if RA=0,
sthx,,Memory,X,31,407,,,,"RS,RA0,RB",,,,"STORE16(val_RA0 + val_RB, val_RS) ; MFCHECK(0)",,,,,,,,A=RA0; B=RB; C=RS,R0=alu_add_ab; R2=C,S16,,,
sthux,,Memory,X,31,439,,,,"RS,RA,RB",,RA,,"ADR x = val_RA + val_RB ; STORE16(x, val_RS); val_RA = x ; MFCHECK(0)",,,,,,,,A=RA; B=RB; C=RS,R0=alu_add_ab; R2=C,S16; R0,RA=R0,FIXME: UNDEF if RA=0,
stmw,,Memory,D,47,,,,,"RS,D,RA0",,,,,,,,,,,,A=RA0; B=D; C=RS; state_stmw,R0=alu_add_ab; R2=C,S32,,"DE does load_RX. Moves into stmw state, which then invokes the next line",
stmw-state_stmw,,Synthetic,,,,,,,,,,,,,,,,,,,C=RX,R0=alu_add_R0_4; R2=C,S32,,"DE does inc_RX.  Currently this isn’t auto-generated into decoders for RTL/MR, and this behaviour is coded by hand.  There are suitably few DE-cracked instructions that this is probably OK.",
stswi,,Memory,X,31,725,,,,"RS,RA0,NB",,,,,,,,,,H,,FC_ILL_HYP,,,,String,
stswx,,Memory,X,31,661,,,,"RS,RA0,RB",,,,,,,,,,H,,FC_ILL_HYP,,,,String,
stw,,Memory,D,36,,,,,"RS,RA0,D",,,,"STORE32(val_RA0 + D, val_RS) ; MFCHECK(0)",,,,,,,,A=RA0; B=D; C=RS,R0=alu_add_ab; R2=C,S32,,,
stwbrx,,Memory,X,31,662,,,,"RS,RA0,RB",,,,"STORE32(val_RA0 + val_RB, BSWAP32(val_RS)) ; MFCHECK(0)",,,,,,,,A=RA0; B=RB; C=RS,R0=alu_add_ab; R2=C,S32_BS,,,
stwcx,.,Memory,X,31,150,,,,"RS,RA0,RB",,,CR,,A,,,,,,,A=RA0; B=RB; C=RS; D=XERCR,R0=alu_add_ab; RC=D; R2=C,S32_RSV,XERCR=RC,"synch, note bit 0 must be 1 else undef",
stwu,,Memory,D,37,,,,,"RS,RA,D",,RA,,"ADR x = val_RA + D ; STORE32(x, val_RS); val_RA = x ; MFCHECK(0)",,,,,,,,A=RA; B=D; C=RS,R0=alu_add_ab; R2=C,S32; R0,RA=R0,,
stwx,,Memory,X,31,151,,,,"RS,RA0,RB",,,,"STORE32(val_RA0 + val_RB, val_RS) ; MFCHECK(0)",,,,,,,,A=RA0; B=RB; C=RS,R0=alu_add_ab; R2=C,S32,,,
stwux,,Memory,X,31,183,,,,"RS,RA,RB",,RA,,"ADR x = val_RA + val_RB ; STORE32(x, val_RS); val_RA = x ; MFCHECK(0)",,,,,,,,A=RA; B=RB; C=RS,R0=alu_add_ab; R2=C,S32; R0,RA=R0,,
subf,".,o",Arithmetic,XO,31,40,,,,"RA,RB",,RT,,"ADD_OV_CI(val_RT, val_OV, ~val_RA, val_RB, 1)",1,1,,,,,,A=RA; B=RB; if (Rc || SO) D=XERCR,R0=alu_sub_ba; RC=Rc_SO,R0,RT=R0; if (Rc || SO) XERCR=RC,,
subfc,".,o",Arithmetic,XO,31,8,,,,"RA,RB",,RT,CA,"ADD_OV_CO_CI(val_RT, val_OV, val_CA, ~val_RA, val_RB, 1)",1,1,,,,,,A=RA; B=RB; D=XERCR,R0=alu_sub_ba; RC=Rc_SO_CA,R0,RT=R0; XERCR=RC,,
subfe,".,o",Arithmetic,XO,31,136,,,,"RA,RB",CA,RT,CA,"ADD_OV_CO_CI(val_RT, val_OV, val_CA, ~val_RA, val_RB, val_CA)",1,1,,,,,,A=RA; B=RB; D=XERCR,R0=alu_sub_ba_d; RC=Rc_SO_CA,R0,RT=R0; XERCR=RC,,
subfic,,Arithmetic,D,8,,,,,"RA,SI",,RT,CA,"ADD_CO_CI(val_RT, val_CA, ~val_RA, SI, 1)",,,,,,,,A=RA; B=SI; D=XERCR,R0=alu_sub_ba; RC=CA,R0,RT=R0; XERCR=RC,,
subfme,".,o",Arithmetic,XO,31,232,,,,RA,CA,RT,CA,"ADD_OV_CO_CI(val_RT, val_OV, val_CA, ~val_RA, -1, val_CA)",1,1,,,,,,A=RA; D=XERCR,R0=alu_sub_a_m1_d; RC=Rc_SO_CA,R0,RT=R0; XERCR=RC,check ???,
subfze,".,o",Arithmetic,XO,31,200,,,,RA,CA,RT,CA,"ADD_OV_CO_CI(val_RT, val_OV, val_CA, ~val_RA, 0, val_CA)",1,1,,,,,,A=RA; D=XERCR,R0=alu_sub_a_0_d; RC=Rc_SO_CA,R0,RT=R0; XERCR=RC,,
sync,,Special,X,31,598,,,,"L,E",,,,,,,,,,,,,,,,"Barrier; also ptesync, lwsync.  NOP until not SC!",
tw,,Trap,X,31,4,,,,"TO,RA,RB",,,,,,,,,,,,A=RB; B=RA; C=TO,R0=alu_sub_ba; RC=Rc; R1=C,test_trap_R1_RC,,MEM self-NOPs if trap not taken,
twi,,Trap,D,3,,,,,"TO,RA,SI",,,,,,,,,,,,A=SI; B=RA; C=TO,R0=alu_sub_ba; RC=Rc; R1=C,test_trap_R1_RC,,,
xor,.,Logical,X,31,316,,,,"RS,RB",,RA,,val_RA = val_RS ^ val_RB,1,,,,,,,A=RS; B=RB; if (Rc) D=XERCR,R0=alu_xor_ab; RC=Rc,R0,RA=R0; if (Rc) XERCR=RC,,
xori,,Logical,D,26,,,,,"RS,UI",,RA,,val_RA = val_RS ^ UI,,,,,,,,A=RS; B=UI,R0=alu_xor_ab,R0,RA=R0,,
xoris,,Logical,D,27,,,,,"RS,UI",,RA,,val_RA = val_RS ^ ((REG)UI<<16),,,,,,,,A=RS; B=UI_HI,R0=alu_xor_ab,R0,RA=R0,,
DEBUG,,Special,X,5,69,,,,RA,,,,,,,,,,,,A=RA,R0=debug,R0,RA=R0,Matches opcode 0xdeadbeef also.,
dcba,,Cache,X,31,758,,,,"RA0,RB",,,,NOP(); (void)val_RA0; (void)val_RB;,,,,,,,,,,,,NOP,
dcbi,,Cache,X,31,470,,,,"RA0,RB",,,,LOAD8(val_RA0+val_RB) ; MFCHECK(1),,,,,,S,,A=RA0; B=RB,R0=alu_add_ab,DC_INV,,Invalidate R0. Supervisor only.  Needs write perms; DSI,
dcbf,,Cache,X,31,86,,,,"RA0,RB",,,,LOAD8(val_RA0+val_RB) ; MFCHECK(1),,,,,,,,A=RA0; B=RB,R0=alu_add_ab,DC_CINV,,"Clean/inv R0.  Needs R perms, can DSI.  Note L field not represented yet.",
dcbt,,Cache,X,31,278,,,,"RA0,RB,TH",,,,NOP(); (void)val_RA0; (void)val_RB;,,,,,,,,,,,,NOP (implement when D$ decoupled from pipeline!)  Prefetch.  No fault.,
dcbst,,Cache,X,31,54,,,,"RA0,RB",,,,LOAD8(val_RA0+val_RB) ; MFCHECK(1),,,,,,,,A=RA0; B=RB,R0=alu_add_ab,DC_CLEAN,,Clean R0. Needs RPerm. Can invoke DSI,
dcbtst,,Cache,X,31,246,,,,"RA0,RB,TH",,,,NOP(); (void)val_RA0; (void)val_RB;,,,,,,,,,,,,NOP.  Prefetch for store.  No fault.,
dcbz,,Cache,X,31,1014,,,,"RA0,RB",,,,"for (int i = 0; i < 8; i++) { STORE32(((val_RA0+val_RB) & ~31)+(i*4), 0); MFCHECK(0); }",,,,,,,,A=RA0; B=RB,R0=alu_add_ab,DC_BZ,,"Needs write perms. Fault address FIXME:  DAR needs to be ‘EA’, i.e. addressed byte.  Given it’s impossible for a block to partially fault, this’ll do.",
icbi,,Cache,X,31,982,,,,"RA0,RB",,,,,,,2,,,,,A=RA0; B=RB,R0=alu_add_ab,IC_INV,,"Needs read perms, can DSI. I$ invalidate R0.  CHECK: synchronisation",
icbt,,Cache,X,31,22,,,,"CT,RA0,RB",,,,NOP(); (void)val_RA0; (void)val_RB;,,,,,,,,,,,,NOP,
mfsr,,Special,X,31,595,,,,SR,,RT,,,,,,,,S,1,B=SR,R1=B,SR_READ,RT=R0,,
mfsrin,,Special,X,31,659,,,,RB,,RT,,,,,,,,S,1,B=RB,R1=B,SR_READ,RT=R0,,
mtsr,,Special,X,31,210,,,,"SR,RS",,,,,,,,,,S,1,A=RS; B=SR,R0=A; R1=B,SR_WRITE; TLBIA,,SR changes invalidate ERAT/TLBs that store SR+HTAB contents!,
mtsrin,,Special,X,31,242,,,,"RS,RB",,,,,,,,,,S,1,A=RS; B=RB,R0=A; R1=B,SR_WRITE; TLBIA,,,
tlbie,,Special,X,31,306,,,,"RB,L",,,,,,,2,,,H,,C=RB,R0=C,TLBI_R0,,601-604 instruction doesn't have L.  (R0 ~= VA.),
tlbiel,,Special,X,31,274,,,,"RB,L",,,,,,,2,,,H,,C=RB,R0=C,TLBI_R0,," ISA says “This instruction is privileged”, but tibia is HYP, is this a typo?",
tlbia,,Special,X,31,370,,,,,,,,mmu->tlbia(),,,2,,,H,,,,TLBIA,,Invalidate all,
tlbsync,,Special,X,31,566,,,,,,,,NOP(),,,2,,,H,,,R2=PC4; br_annul,newpc=R2,,Looks like isync?,
*,,,,,,,,,,,,,,,,,,,,,FC_ILL,,,,TLBI is a POWER family instruction….,
,,,,,,,,,,,,,,,,,,,,,,,,,What about mtocrf et al?,
